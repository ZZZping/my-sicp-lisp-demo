#lang sicp
(#%require "pub_method.rkt")
;;(define (make-rat n d) (cons n d))
(define (make-rat n d)
  (let ((g (gcd n d)))
  (cons (/ n g) (/ d g))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (linear-combination a b x y)
  (+ (* a x) (* b y)))

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
;;(define (print-rat x) (newline) (display (numer x)) (display "/") (display (denom x)))
;;(define (print-rat-1 x) (if (= (numer x) (denom x)) (display (numer x))))
(define (print-rat x)
  (cond ((=
          (numer x)
          (denom x))
         (newline)
         (display (numer x)))
        (else
         (newline)
         (display (numer x))
         (display "/")
         (display (denom x)))))
(define one-half (make-rat 1 2))
(define one-one (make-rat 1 1))
;;(print-rat one-half)
;;(print-rat one-one)
(define one-third (make-rat 1 3))
;;(print-rat (add-rat one-half one-third))
;;(print-rat (mul-rat one-half one-third))
;;(print-rat (add-rat one-third one-third))
;;(print-rat (add-rat one-half one-half))


;;2.2
;;points
(define (make-point x y) (cons x y))
(define (x-point p) (car p))
(define (y-point p) (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
;;segment
(define (make-segment start-point end-point) (cons start-point end-point))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))
(define (midpoint-segment segment)
  (define (average a b)
    (/ (+ a b) 2.0))
  (let ((a (start-segment segment))
        (b (end-segment segment)))
    (make-point (average (x-point a) (x-point b))
                (average (y-point a) (y-point b)))))
;;test
;;(define seg (make-segment (make-point 2 3) (make-point 10 15)))
;;(print-point (midpoint-segment seg))

;;rectangle
(define (make-rect bottom-left top-right) (cons bottom-left top-right))
(define (make-rect-width-height bottom-left width height)
  (cons bottom-left (cons width height)))
(define (bottom-left rect) (car rect))
(define (bottom-right rect)
  (make-point (x-point (cdr rect))
              (y-point (car rect))))
(define (top-left rect)
  (make-point (x-point (car rect))
              (y-point (cdr rect))))
(define (top-right rect) (cdr rect))
(define (width-rect rect)
  (abs (- (x-point (bottom-left rect))
          (x-point (bottom-right rect)))))
(define (rect-width rect)
  (car (cdr rect)))
(define (height-rect rect)
  (abs (- (y-point (bottom-left rect))
          (y-point (top-left rect)))))
(define (rect-height rect)
  (cdr (cdr rect)))
;;public method
(define (area-rect rect)
  (* (width-rect rect) (height-rect rect)))
(define (area-rect1 rect)
  (* (rect-width rect) (rect-height rect)))
(define (perimeter-rect rect)
  (* (+ (width-rect rect) (height-rect rect)) 2))
(define (perimeter-rect1 rect)
  (* (+ (rect-width rect) (rect-height rect)) 2))
;;test rectangale
(define r (make-rect (make-point 1 1) (make-point 3 7)))
;;(area-rect r)
;;(perimeter-rect r)
(define r1 (make-rect-width-height (make-point 1 1) 2 6))
;;(area-rect1 r1)
;;(perimeter-rect1 r1)

;;2.1.3
;;(define (cons x y)
;;  (define (dispatch m)
;;    (cond ((= m 0) x)
;;          ((= m 1) y)
;;          (else (error "Arguments not 0 or 1: CONS" m))))
;;  dispatch)
;;(define (car z) z 0)
;;(define (cdr z) z 1)

;;;2.4
;;(define (cons a b)
;;  (lambda (m) (m a b)))

;;(define (car z)
;;  (z (lambda (p q) p)))
;;(car (cons 1 2))
;;(car (lambda (m) (m 1 2)))
;;((lambda (z) (z (lambda (p q) p)))
;; (lambda (m) (m 1 2)))
;;((lambda (m) (m 1 2))
;; (lambda (p q) p))
;;((lambda (p q) q) 1 2)

;;2.1.4 & 2.7
(define (make-interval a b) (cons a b))
(define (lower-bound interval) (min (car interval) (cdr interval)))
(define (upper-bound interval) (max (car interval) (cdr interval)))
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))
;;sub-interval
(define (sub-interval-with-add-interval x y)
  (add-interval x (make-interval (- (upper-bound y)) (- (lower-bound y)))))
(define (negate-interval interval)
  (make-interval (* -1 (lower-bound interval)) (* -1 (upper-bound interval))))
(define (sub-interval-1 x y)
  (let ((y (negate-interval y)))
    (add-interval x y)))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
(define (display-interval interval)
  (newline)
  (display "[")
  (display (lower-bound interval))
  (display ",")
  (display (upper-bound interval))
  (display "]"))
;;test
;;(define i (make-interval 2 7))
;;(define j (make-interval 8 3))
;;(display-interval i)
;;(display-interval j)
;;(display-interval (sub-interval i j))
;;(display-interval (sub-interval j i))
;;(display-interval (add-interval i j))
;;(display-interval (mul-interval i j))
;;(display-interval (div-interval i j))

;;2.2
;;(cons (cons 1 2) (cons 3 4))
;;(cons 1 (cons 2 (cons 3 (cons 4 nil))))
;;(list 1 2 3 4)
(define one-through-four (list 1 2 3 4))
;;(cadr <arg>) --> (car (cdr <arg>))
;;(cadr one-through-four)
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define (length-iterative items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
(define (append-m list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append-m (cdr list1) list2))))
(define (last-pairs items)
  (if (= (length items) 1) (car items)
      (last-pairs (cdr items))))
;;consider empty list
(define (last-pairs-1 items)
  (let ((rest (cdr items)))
    (if (null? rest) items
        (last-pairs-1 rest))))
;;2.18
(define (reverse items)
  (if (null? (cdr items))
      items
      (append (reverse (cdr items)) (cons (car items) nil))))
;;(1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5)
;;(1) (2) (3) (4)
;;
;;2.20
(define (same-parity first . rest)
  (let ((yes? (if (even? first)
                  even?
                  odd?)))
    (define (iter items result)
      (if (null? items)
          (reverse result)
          (iter (cdr items) (if (yes? (car items))
                                (cons (car items) result)
                                result))))
    (iter rest (list first))))
(list-ref one-through-four 3)
(length one-through-four)
(length-iterative one-through-four)
(append-m one-through-four one-through-four)
(last-pairs one-through-four)
(define o-t-f (list 1 2 3 4 5))
(reverse o-t-f)
(define one1 (list 1))
