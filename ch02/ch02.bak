#lang sicp
; (#%require "pub_method.rkt")
;;square
(define (square x) (* x x))
(define square-lambda (lambda (x) (* x x)))
;;fib
(define (fib-iter a b p q count)
  (cond ((= count 0) 0)
        ((even? count) (fib-iter a b (+ (square p) (square q)) (* 2 (* p q)) (/ count 2)))
        (else (fib-iter (+ (* b q) (* a (+ p q))) (+ (* b p) (* a q)) p q (- count 1)))))
(define (fib-0 n)
  (fib-iter 1 0 1 1 n))

;;another fib
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
;;(define (make-rat n d) (cons n d))
(define (make-rat n d)
  (let ((g (gcd n d)))
  (cons (/ n g) (/ d g))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (linear-combination a b x y)
  (+ (* a x) (* b y)))

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
;;(define (print-rat x) (newline) (display (numer x)) (display "/") (display (denom x)))
;;(define (print-rat-1 x) (if (= (numer x) (denom x)) (display (numer x))))
(define (print-rat x)
  (cond ((=
          (numer x)
          (denom x))
         (newline)
         (display (numer x)))
        (else
         (newline)
         (display (numer x))
         (display "/")
         (display (denom x)))))
(define one-half (make-rat 1 2))
(define one-one (make-rat 1 1))
;;(print-rat one-half)
;;(print-rat one-one)
(define one-third (make-rat 1 3))
;;(print-rat (add-rat one-half one-third))
;;(print-rat (mul-rat one-half one-third))
;;(print-rat (add-rat one-third one-third))
;;(print-rat (add-rat one-half one-half))


;;2.2
;;points
(define (make-point x y) (cons x y))
(define (x-point p) (car p))
(define (y-point p) (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
;;segment
(define (make-segment start-point end-point) (cons start-point end-point))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))
(define (midpoint-segment segment)
  (define (average a b)
    (/ (+ a b) 2.0))
  (let ((a (start-segment segment))
        (b (end-segment segment)))
    (make-point (average (x-point a) (x-point b))
                (average (y-point a) (y-point b)))))
;;test
;;(define seg (make-segment (make-point 2 3) (make-point 10 15)))
;;(print-point (midpoint-segment seg))

;;rectangle
(define (make-rect bottom-left top-right) (cons bottom-left top-right))
(define (make-rect-width-height bottom-left width height)
  (cons bottom-left (cons width height)))
(define (bottom-left rect) (car rect))
(define (bottom-right rect)
  (make-point (x-point (cdr rect))
              (y-point (car rect))))
(define (top-left rect)
  (make-point (x-point (car rect))
              (y-point (cdr rect))))
(define (top-right rect) (cdr rect))
(define (width-rect rect)
  (abs (- (x-point (bottom-left rect))
          (x-point (bottom-right rect)))))
(define (rect-width rect)
  (car (cdr rect)))
(define (height-rect rect)
  (abs (- (y-point (bottom-left rect))
          (y-point (top-left rect)))))
(define (rect-height rect)
  (cdr (cdr rect)))
;;public method
(define (area-rect rect)
  (* (width-rect rect) (height-rect rect)))
(define (area-rect1 rect)
  (* (rect-width rect) (rect-height rect)))
(define (perimeter-rect rect)
  (* (+ (width-rect rect) (height-rect rect)) 2))
(define (perimeter-rect1 rect)
  (* (+ (rect-width rect) (rect-height rect)) 2))
;;test rectangale
(define r (make-rect (make-point 1 1) (make-point 3 7)))
;;(area-rect r)
;;(perimeter-rect r)
(define r1 (make-rect-width-height (make-point 1 1) 2 6))
;;(area-rect1 r1)
;;(perimeter-rect1 r1)

;;2.1.3
;;(define (cons x y)
;;  (define (dispatch m)
;;    (cond ((= m 0) x)
;;          ((= m 1) y)
;;          (else (error "Arguments not 0 or 1: CONS" m))))
;;  dispatch)
;;(define (car z) z 0)
;;(define (cdr z) z 1)

;;;2.4
;;(define (cons a b)
;;  (lambda (m) (m a b)))

;;(define (car z)
;;  (z (lambda (p q) p)))
;;(car (cons 1 2))
;;(car (lambda (m) (m 1 2)))
;;((lambda (z) (z (lambda (p q) p)))
;; (lambda (m) (m 1 2)))
;;((lambda (m) (m 1 2))
;; (lambda (p q) p))
;;((lambda (p q) q) 1 2)

;;2.1.4 & 2.7
(define (make-interval a b) (cons a b))
(define (lower-bound interval) (min (car interval) (cdr interval)))
(define (upper-bound interval) (max (car interval) (cdr interval)))
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))
;;sub-interval
(define (sub-interval-with-add-interval x y)
  (add-interval x (make-interval (- (upper-bound y)) (- (lower-bound y)))))
(define (negate-interval interval)
  (make-interval (* -1 (lower-bound interval)) (* -1 (upper-bound interval))))
(define (sub-interval-1 x y)
  (let ((y (negate-interval y)))
    (add-interval x y)))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
(define (display-interval interval)
  (newline)
  (display "[")
  (display (lower-bound interval))
  (display ",")
  (display (upper-bound interval))
  (display "]"))
;;test
;;(define i (make-interval 2 7))
;;(define j (make-interval 8 3))
;;(display-interval i)
;;(display-interval j)
;;(display-interval (sub-interval i j))
;;(display-interval (sub-interval j i))
;;(display-interval (add-interval i j))
;;(display-interval (mul-interval i j))
;;(display-interval (div-interval i j))

;;2.2
;;(cons (cons 1 2) (cons 3 4))
;;(cons 1 (cons 2 (cons 3 (cons 4 nil))))
;;(list 1 2 3 4)
(define one-through-four (list 1 2 3 4))
;;(cadr <arg>) --> (car (cdr <arg>))
;;(cadr one-through-four)
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define (length-iterative items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
(define (append-m list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append-m (cdr list1) list2))))
(define (last-pairs items)
  (if (= (length items) 1) (car items)
      (last-pairs (cdr items))))
;;consider empty list
(define (last-pairs-1 items)
  (let ((rest (cdr items)))
    (if (null? rest) items
        (last-pairs-1 rest))))
;;2.18
(define (reverse items)
  (if (null? (cdr items))
      items
      (append (reverse (cdr items)) (cons (car items) nil))))
;;(1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5)
;;(1) (2) (3) (4)
;;
;;2.20
(define (same-parity first . rest)
  (let ((yes? (if (even? first)
                  even?
                  odd?)))
    (define (iter items result)
      (if (null? items)
          (reverse result)
          (iter (cdr items) (if (yes? (car items))
                                (cons (car items) result)
                                result))))
    (iter rest (list first))))
;;map over list
(define (scal-list items factor)
  (if (null? items) nil
      (cons (* (car items) factor)
            (scal-list (cdr items) factor))))
;;abstract map
(define (map proc items)
  (if (null? items) nil
      (cons (proc (car items))
            (map proc (cdr items)))))
;;my map
;;(map (lambda (x y) (+ x (* 2 y))) (list 1 2 3) (list 1 2 3))

;;2.21
(define (square-list-common items)
  (if (null? items) nil
      (cons (* (car items) (car items))
            (square-list-common (cdr items)))))
(define (square-list-map items)
  (map (lambda (x) (* x x)) items))
;;2.23
(define (for-each-0 proc items)
  (if (null? items) nil
      (and (proc (car items)) (for-each-0 proc (cdr items)))))
(define (for-each-1 proc items)
  (let ((items-cdr (cdr items)))
    (proc (car items))
    (if (not (null? items-cdr))
        (for-each-1 proc items-cdr)
        true)))
(define (for-each-2 proc items)
  (cond ((not (null? items))
         (proc (car items))
         (for-each-2 proc (cdr items)))))
;;(list-ref one-through-four 3)
;;(length one-through-four)
;;(length-iterative one-through-four)
;;(append-m one-through-four one-through-four)
;;(last-pairs one-through-four)
(define o-t-f (list 1 2 3 4 5))
;;(reverse o-t-f)
;;(scal-list one-through-four 10);
;;(map + (list 1 2 3) (list 4 5 6))
;;(map abs (list 1 -2 3 -4 5))
;;(map (lambda (x) (* x 2)) o-t-f)
;;(map (lambda (x) (* x 10)) (list 1 2 3 4))
;;(square-list-map (list 1 2 3 4))
;;(square-list-common (list 1 2 3 4))
;;(for-each-2 (lambda (x) (newline) (display x)) (list 1 2 3 4))

;;Hierarchical Structures
(define x (cons (list 1 2) (list 3 4)))
;;count-leaves
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))

;;(count-leaves (list (list (list 1 2 3) 4) 5))
;;map tree
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
;;test
;;(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)

(define (scale-tree-1 tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree) (scale-tree-1 sub-tree factor)
              (* sub-tree factor)))
       tree))
;;test
;;(scale-tree-1 (list 1 (list 2 (list 3 4) 5) (list 6 7)) 9)

;;sequence as conventional interface
;;take a tree as a argument and computes the sum of the
;;square of the levels that are odd
(define (sum-odd-square tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-square (car tree))
                 (sum-odd-square (cdr tree))))))
;;Fib(k)
(define (even-fibs n)
  (define (next k)
    (if (> k n) nil
        (let ((f (fib k)))
          (if (even? f) (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
;;sequence operations
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
(filter odd? (list 1 2 3 4 5))
; (map square (list 1 2 3 4))
(define (accumulate op initial sequances)
  (if (null? sequances) initial
      (op (car sequances)
          (accumulate op initial (cdr sequances)))))
;;test
; (accumulate + 10 (list 1 2 3 4 5))
; (accumulate * 10 (list 1 2 3 4 5))
; (accumulate cons nil (list 1 2 3 4 5))
(define (enumrate-interval low high)
  (if (> low high) nil
      (cons low (enumrate-interval (+ low 1) high))))
; (enumrate-interval 2 7)
(define (enumrate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumrate-tree (car tree))
                      (enumrate-tree (cdr tree))))))
;;test
; (enumrate-tree (list 1 (list 2 (list 3 4)) 5))
(define (sum-odd-squares tree)
  (accumulate + 0 (map square (filter odd? (enumrate-tree tree)))))
;;test
; (sum-odd-squares (list 1 (list 2 (list 3 4) 5) (list 6 7)))
;;ebumrate the integers from 0 to n, generate the Fibonacci number
;;for each of this integers, filter the result sequence to keep only
;;the even elements, and accumulate the results into a list
(define (new-even-fibs n)
  (accumulate
   cons
   nil
   (filter even? (map fib (enumrate-interval 0 n)))))
;;test
; (new-even-fibs 8)

;;list-fib-squares
;;We can reuse pieces from sum-odd-squares and even-fibs procedures in a
;;program that constructs a list of the squares of the first n+1 Fibonacci
;;numbers.
(define (list-fib-squares n)
  (accumulate cons nil (map square (map fib (enumrate-interval 0 n)))))
;;test
; (list-fib-squares 10)
(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))
;;test
; (product-of-squares-of-odd-elements (list 1 2 3 4 5 6 7))

;;A PICTURE LANGUAGR
(#%require sicp-pict)
; (paint einstein)
;(define wave2 (beside wave (flip-vert wave)))
; (define wave2 (beside wave (flip-vert wave)))
; (define wave4 (below wave2 wave2))

(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
; (define wave4 (flipped-pairs wave))

(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
(define (corner-split painter n)
  (if (= n 0) painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
(define (new-flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
(define (new-square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
;test
; (paint (right-split einstein 3))
;(paint (corner-split einstein 6))
;(paint (right-split einstein 6))

;;frames
;;A frame can be described by three vectorsâ€”an origin vector and two edge vectors.
(define (frame-coord-map frame)
  (lambda (v) (add-vect (origin-frame frame)
                        (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
                                  (scale-vect (ycor-vect v) (edge2-frmae frame))))))
;;ex2.46
(define (make-vect x y) (cons x y))
(define (xcor-vect vec) (car vec))
(define (ycor-vect vec) (cdr vec))
(define (eq-vect? v1 v2)
  (and (= (xcor-vect v1) (xcor-vect v2))
       (= (ycor-vect v1) (ycor-vect v2))))
(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1) (xcor-vect v2))
             (+ (ycor-vect v1) (ycor-vect v2))))
(define (sub-vect v1 v2)
  (maker-vect (- (xcor-vect v1) (xcor-vect v2))
              (- (ycor-vect v1) (ycor-vect v2))))
(define (scale-vect s vec)
  (make-vect (* s (xcor-vect vec))
             (* s (ycor-vect vec))))
;;ex2.47
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (frame-origin f) (car f))
(define (frame-edge1 f) (cadr f))
(define (frame-edge2 f) (caddr f))
;test
; (paint (right-split einstein 3))